# Capstone
Final project for class. Consists of PERN (Postgres, Express, React, Node) stack. Meant to test ability of gamification (largely incomplete). THIS PROJECT ONLY WORKS ON LOCAL MACHINE AND IS ENTIRELY A PROOF OF CONCEPT AS OPPOSED TO A WORKING WEBSITE
## Dueling Masters, Made Software
	Among my peers and throughout my college life, many of us in the computer science field had attempted a common challenge, the automation of a well-known game called “Dueling Masters”. Dueling Masters is a Dungeons and Dragons stylized fighting game, in which two (or more) players enter an imaginative arena and fight it out until one is left standing. Currently, the game is facilitated through a number of Game Masters, who calculate just about everything and make the judgment call for all rules, which is ultimately inefficient should the game go widespread. While attempts have been made to create discord bots to simplify, or outright automate, the issue, most of these projects have been scrapped. My project is a theoretical attempt at fixing this issue using a completely different approach. In this day and age, software development has spread far and wide, resulting in advanced or creative products which can ultimately provide a solution to just about any problem. Using the experience I have accumulated, as well as some down-scaling for simplicity sake, I will be testing if basic software stacks can pass the test of creating a text based RPG much like that of Dueling masters. 
### The Approach
	When I declared this project, I immediately knew I wouldn’t be able to completely replicate what currently exists in the Dueling Masters. To make it simple, combat can be broken down effectively into four phases: turn start, action, response, and result. Turn start stands as its own phase because of the existence of status effects, which I wanted to implement to the best of my ability starting out. Simply put, a status effect is applied in the result phase, and its effects are calculated/reverted at the start of that respective player's turn. In total, there are 25 separate effects, some which come with an abnormal condition or calculation. The action phase is where a player (on their turn) chooses their action for the turn, which can either be offensive or defensive. Defensive actions in this case skip the response phase, as it only affects the player using the action. Available actions are a combination of class and race abilities, combined with the universal attack action. In Dueling Masters, there are 15 classes and 16 races. Response phase happens when a player makes an offensive action and rolls for it. The defending player has the choice to either dodge the attack or counter it. The core difference between these two actions is the risk/reward factor. Dodging means a player safely negates the effect or damage in question, while counter means a player deals their own damage on top of negating the damage. However, while failing a dodge simply results in taking damage, failing a counter costs the defending player their entire turn. Finally, the results phase is calculating whether or not the response was a success or a failure, and determining the damage done for it. 
	The first step in recreating Dueling Masters was carefully choosing what data would be the easiest to utilize in this setting, while not limiting the game too much. I chose to start off my project by migrating all of this information into Postgres, which meant that I had to also know what type of data I would be storing for each section of information. While Dueling Masters normally allows three characters per account, this would expand the game too much, considering the down-scaling of the classes and races available. Instead, I created a table called Users, which held a randomly generated identifier as the primary key, required an email and password (which were unencrypted for simplicity's sake), and stored all of the information needed to create exactly one character. This information would include the chosen class, chosen race, health, energy, mana, the six combat stats, and available skill points for allocating to the aforementioned six stats. 
	Following this, I also needed to implement a way to facilitate battles. My solution was adding a live chat feature, which would display whenever a user wanted to battle. This quickly didn’t work in a logical sense, and I was forced to separate the live chat from the battle. While there is code for the live chat, there is no usage for it other than communication between users. As for the battle, I chose to limit it to 1v1 settings to make it as simple as possible, copying the stats of the users participating in battle for the purpose of data manipulation. A unique identifier, similar to the user’s, would be generated to differentiate between each battle. Additionally, this identifier would serve as the foreign key for two additional tables, active effects and cooldown abilities. These two tables serve to determine what effects are currently in play or what abilities are on cooldown and label which player is under that given effect/cooldown.
### Data Migration
Of the 25 effects, I chose to implement 20: Bleed, Blind, Dizzy, Stun, Adrenaline, Exhaustion, Poison, Burn, Paralysis, Chilled, Frozen, Fear, Attack up, Swiftness, Defense up, Magic up, Spell Ward, Healing, Stealth, and Evasion. Effects generally function the same, requiring similar information: name, type of effect (either damage or status), phase of combat it affected (which was erroneously used, resulting in wasted data), the stats it modified (ex: if it reduces a given stat by X, the modifier would be -X), and the duration. 
Of the available 15 classes, I chose to implement 5, and all of their abilities up to only level 5, as opposed to level 12 in Dueling Masters: Archer, Brawler, Berserker, Mage, Cleric. I chose these classes in particular because of their apparent simplicity. The remaining classes had mechanics which I was almost entirely ignoring for the sake of completing the project to the best of my ability. Additionally, the class table only had their respective attack modifiers and stat bonuses. The primary idea was to make a separate table called “class abilities” and link it together with a foreign key to that respective class. This is where I unintentionally complicate my project considerably. The class ability table stored the following: the name of the class the ability belonged to, the name of the ability, the phase of combat it can be used in (which was an error, as all actions should only be usable in the action phase), the conditions (which complicates the logic of the game considerably, but serves as a label to what each ability does), the effect it applies (if any), the “amplification” (which in this case represents the actual damage it is supposed to do), the “multiplier” (which indicates how many times one can attack, but ultimately went unused due to faulty programming), level required to use it, all of the modifiers identical to the effects table (which only applied to a singular ability, resulting in a huge waste of data, and a major flaw in the logic), and the cost of the ability in question (which, again, went unused). This table was easily the worst of the bunch, which easily could have been fixed by migrating certain abilities to other portions of different tables, which I ultimately failed to notice until late in development. 
Using a similar approach, I implemented 8 of the 16 races and their respective abilities. Each race in the table had a base health, mana, and energy, as well as a bonus to the six combat stats. There was also a bonus to skill points, which was intended to provide a bonus to how many points a user can allocate to their six stats, but it also went unused in the final version. The more complicated of the bunch, racial abilities, had similar issues to the class abilities, but considerably worse due to particular factors. Each ability had a special condition, and was, more often than not, a permanent ability. Each race as a factor in every battle would’ve been a lengthy process. Ultimately, every race ability, except for stone essence for dwarves (which is heavily bugged), went unused. Lastly, there existed a table for races called Immunities, which determined what effects a given race is immune to, but it was also unused during development. 
### Backend Development
	Starting the programming, I figured development would begin best with the PERN (Postgres, Express, React, Node) stack, as I am most familiar with it. It started with the following and simplification of an old project I had worked on last year, which worked with logins and registering new users. I knew I didn’t have to go to the lengths of my original project, which encrypted passwords and verified that email addresses were valid, so I greatly simplified it. Starting with index.js, I declared all essential libraries and routes before starting a local port on my computer using Node.
Moving onto auth.js, this functioned as the first and easiest challenge toward my project, as it was a rinse and repeat of an old project I had worked on. Auth consists of a route for login and register. These are two functions that request user information and check if the information is valid based on the specific needs. If a user is registering, for example, it will make sure the user's information is original. Otherwise, if a user is logging in, it will check if their password and email is correct. Upon the correct information being put into login, a token will be output, which is meant to be placed into the users req.header. This is important as this will determine whether or not a user is logged in or not. 
The dashboard comes next, and is much more demanding compared to auth. Since this is a new file, and it extends beyond what my old project covered, I very much had to freestyle it moving forward, while testing/debugging features to ensure functionality of each route. The main route simply displayed the users character information, which is usually done for the purpose of character creation as well as future stat allocation. The next four routes are all “get” commands, which cover class and race information. However, due to insufficient data migration, no description exists for any of the classes, meaning the information is very cryptic. Additionally, racial information came with the flaw of displaying “[object object]” when trying to display the racial abilities and immunities at the same time, but was fixed by utilizing inner joins. Following the information display came character creation, which was a very large “put” command. This function required a chosen race, class, all 6 selected stats (properly allocated), and skill points used (which should always be 10). It will check the skill points used and determine whether you have properly allocated 10 points or don’t have a character, and will throw an error if either of these are false. Otherwise, it will grab all of the relevant information and update the user’s profile with their brand new character. The next routes dealt with the live chat and posting messages. It was a rather short function which grabbed a unique message, and the user who typed it, and inserted it into a table called chat. Another command would display all of the chat information in order of oldest first. The next set of routes had to deal entirely with battles, sorting out the problem of how a battle is made and how to view a battle in the first place. My solution was to start by creating a route to declare battles; these would insert the user that declared the battle into the first participant slot alongside all their stats. From there, another route would look for all battles that are labeled as “active”, which will display the identifier of the active battles for a user to place in their req.header. Finally, to keep track of battles, an extra route is made to list all battles that a given user is currently in, allowing them to switch from one to another if needed. To join any battle, a user has to place the ID of the battle into the body of the “join-battle” route, after which it will check if the user is currently in that given battle, to prevent cheating. If not, then the user will join as a second participant, and the battle will begin.
Lastly for backend development comes battle management, which turned out to hold the challenge of game logic. From the beginning, I thought it would be logically best to utilize the backend for all game logic purposes, due to a large degree of unfamiliarity with React. The first and most basic route is a perpetual check for when a participant in the battle is reduced to 0hp or less at any point. If so, then the last one standing is deemed the winner and granted a reward of a simple level up. I had originally intended to utilize experience points, however, it proved too complicated to implement logistically, resulting in its removal. If no participant is at 0hp or less, then it will simply display the current state of the battle, as well as whose turn it is. If it doesn’t display whose turn it is, then initiative begins. Initiative is a route which generates a random number from 1-20 to determine who goes first. As a note, a universal problem I had was both determining who was accessing the route at any given moment combined with whose turn it was at any moment. I fixed this by adding extra logic to differentiate each user by their req.header, combined with changing the “battle_state” column to indicate the name of whoever has the current turn. Upon initiative being determined (both participants rolling), then turn order is declared, and the battle can begin. The abilities route determines what each participant can do on their turn, with “Attack” and “Pass” universally being available. If it is not a given user's turn, it will simply display that fact, and no ability can be selected. I had originally made an attempt to implement another race ability, the elf’s surprise attack, but the logic proved too straining and uncertain to fully implement, combined with the fact that stealth was one of many effects which were removed from the final product. At the start of each player's turn, the “turn-start” route must be accessed, which would calculate all existing effects and remove them if their durations expire. Turn start turned out to be a highly problematic snippet of code, providing a number of errors when putting it to the test. Many of the solutions were to change the checks involved with certain if statements, as they were reading undefined values, which resulted in an error. Following the turn start, just like described before, is the action route. A user will pick an available action and the calculations will be done for said action. If it is a defensive ability, then their turn will end and the effect is immediately applied. Otherwise, a roll to attack is made, and the defender is forced to respond. This brings the defender to the response phase, which must have an action in question combined with a response being used. A roll is then made in response to the attack and results are calculated whether or not the roll succeeds/fails and if the response is a dodge/counter. Lastly, any effects that need to be applied are also applied. While there was an intended use for conditional and cooldown, the logic at this point was overwhelming, and features had to start getting removed.
### Frontend Development
	Frontend development was easily the most intimidating part of this challenge. While I have worked with React in limited cases, I am largely unfamiliar with how to even get a project off of the ground. This is where a lot of research had to be done to make sure I could get it done properly. When I first did it, I ended up attempting to use heavily outdated libraries, resulting in vulnerabilities and non-functional frontend code. I fixed this by rebuilding my project in a new folder and purposely installing older versions of the libraries I needed, which bypassed the vulnerabilities and enabled the usage of code I normally couldn’t access. From there, I added the essential HTML components and removed the CSS components to ensure I was working on a blank page to begin with. From there, I began mapping out my routes, which I rendered using a series of Switch/Route statements for each respective path I needed. After that, I created the components needed to display those routes, ensuring I properly render each page and get redirected to the proper page if I don’t have access (such as trying to access a dashboard if I’m not logged in). 
	The register route came first in the list, which required a declaration of variables and inputs, as well as an event handler to ensure information can be updated as needed. All of the register information was then plugged into a form, which can be submitted with the click of a button, and accesses a function which accesses the backend functions to register. From there, a user is deemed both registered and logged in, and is immediately sent to the dashboard, with all the information put in the required sections. I would do the same with the login route, but with slightly less information being needed in the process. However, this is when I would notice an unusual issue when testing, which would indicate the premature end to my frontend development. Despite my best analysis and help from peers, I could not figure out a rendering issue when routes would be redirected in the same web session. Refreshing the page would “fix” the issue, but would also reset the data, meaning the dashboard and battle pages could technically never be accessed. A theoretical solution would be to retain all the given information upon refresh, and automatically refresh the page upon switching any component. However, I was not familiar enough with React to implement it. Additionally, this solution was very janky, and would result in very slow battles. 
### Reflections
	I effectively went into this project with my hopes high and not expecting the workload to be as large as I had received. The software stack that I chose was not ideal for running a game even as simple as a text based RPG, simply due to the number of states and moving pieces that exist at any given moment. If I had given myself access to something such as a web game library, I believe this project would have been much more achievable and flexible. A common theme I learned with the process of software development is the idea of removing features to ensure a project/game is completed in a certain amount of time. I am ultimately proud that I was able to do as much as I was able to do, and get a full battle to work in theory. If I were to start over, I would dedicate less of my time programming the backend and more of my time carefully researching the capabilities of React. The frontend of my project met a screeching halt over a bug I couldn’t figure out, and it was largely due to my lack of experience. I believe this is a project I am more than willing to jump back into and make better than before to finally overcome the challenge of  Dueling masters.
